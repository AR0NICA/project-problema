# Problema 암호화 알고리즘 개요서

과거 암호학 기술과 현대 암호화 알고리즘의 혁신적인 통합

## 서론

<u>KR</u> | [EN](doc/en/README_en.md)

프로블레마(Problema)는 라틴어 'Probléma(난제)'에서 이름을 따온 하이브리드 암호화 알고리즘으로, 역사적인 애니그마(Enigma) 암호 시스템의 개념적 우아함과 현대 암호학에서 가장 강력한 알고리즘으로 거론되는 AES(Advanced Encryption Standard)의 보안 특성을 결합한 것이 특징이다. 특히 한글과 영어를 교차지원하여 효과적으로 암호화하고 복호화할 수 있도록 고안되었다.

이 문서에서 프로블레마 알고리즘의 작동 원리, 구성 요소, 암호화 및 복호화 과정을 상세히 설명한다.
해당 알고리즘은 보안전공 학부생의 실습 목적으로 제작되었으며, **실사용을 권장하지 않는다.**

## 참고

프로블레마 알고리즘의 설계 원리를 상세하게 설명한다.
- [알고리즘 설계 원리](doc/problema_design.md)

프로블레마 알고리즘의 전체적인 원리를 이해하기 쉽게 다이어그램으로 표현하였다.
- [전체구조 흐름도](doc/diagram/problema_algorithm_diagram.png)
- [암호화 과정 상세흐름](doc/diagram/encryption_flow_sequence.png)
- [복호화 과정 상세흐름](doc/diagram/decryption_flow_sequence.png)

현재 프로블레마는 완벽히 구현된 상태가 아니므로 몇 가지 문제사항이 존재한다. 다음의 문서를 확인하기 바란다.
- [알고리즘 개선 사항 및 현재 상태 확인하기](doc/improvement_report.md)

## 0.소개

### 0.A 프로블레마 알고리즘 사용방법
```bash
# 컴파일
make

# 암호화
./problema -e -k "비밀키" "암호화할 텍스트"

# 상세 출력 모드로 암호화
./problema -e -k "비밀키" -v "암호화할 텍스트"

# 복호화
./problema -d -k "비밀키" "암호화된 텍스트"

# 도움말
./problema --help

```

### 0.B 암호화 과정과 결과
```bash
ubuntu@ar0nica:~/project_problema $ cd /home/ubuntu && cd /home/ubuntu/problema_project && ./problema -e -k "비밀키" -v "나의 life는 like a 천국이다"
[DEBUG] 디버그 모드 활성화
암호화 모드
[DEBUG] UTF-8 → 유니코드 변환: 34 바이트 → 20 문자
[DEBUG] 암호화 전 문자: U+B098
[DEBUG] 플러그보드 적용 후: U+B098
[DEBUG] 순방향 로터 적용 후: U+AFEA
[DEBUG] 로터 회전 상태: 137 214 95 129 214 55 210 237 
[DEBUG] 역방향 로터 적용 후: U+AE7D
[DEBUG] 암호화 후 문자: U+AE7D
[DEBUG] 암호화 전 문자: U+C758
[DEBUG] 플러그보드 적용 후: U+C758
[DEBUG] 순방향 로터 적용 후: U+C380
[DEBUG] 로터 회전 상태: 138 214 95 129 214 55 210 237 
[DEBUG] 역방향 로터 적용 후: U+C76F
[DEBUG] 암호화 후 문자: U+6912
[DEBUG] 암호화 전 문자: U+0020
[DEBUG] 플러그보드 적용 후: U+0020
[DEBUG] 순방향 로터 적용 후: U+FE70
[DEBUG] 로터 회전 상태: 139 214 95 129 214 55 210 237 
[DEBUG] 역방향 로터 적용 후: U+00CB
[DEBUG] 암호화 후 문자: U+69D9
...

[암호화 과정]
입력 텍스트 (UTF-8): EB 82 98 EC 9D 98 20 6C 69 66 65 EB 8A 94 20 6C 69 6B 65 20 61 20 EC B2 9C EA B5 AD EC 9D B4 EB 8B A4 
유니코드 변환 (UTF-8 → 코드 포인트):
U+B098 (나) → U+C758 (의) → U+0020 ( ) → U+006C (l) → U+0069 (i) → U+0066 (f) → U+0065 (e) → U+B294 (는) → U+0020 ( ) → U+006C (l) → U+0069 (i) → U+006B (k) → U+0065 (e) → U+0020 ( ) → U+0061 (a) → U+0020 ( ) → U+CC9C (천) → U+AD6D (국) → U+C774 (이) → U+B2E4 (다)
로터 및 플러그보드 처리:
- 플러그보드 치환
- 8개 로터 순방향 통과
- 로터 회전
- 8개 로터 역방향 통과
- AES 변환 적용
암호화된 출력 (UTF-8): EA B9 BD E6 A4 92 E6 A7 99 E6 A1 85 E6 A7 8A E9 98 A5 E6 A7 8B ED AB 8B E2 90 8D E2 90 AB E2 92 9C E2 90 BD ED AF A7 ED AA A1 ED AC B0 ED A9 A0 E1 87 93 EB B8 BE E7 A5 B4 EC AF A2 
[DEBUG] 프로블레마 컨텍스트 해제 완료
```

```bash
ubuntu@ar0nica:~ $ cd /home/ubuntu && cd /home/ubuntu/project_problema && ./problema -e -k "비밀키" "나의 life는 like a 천국이다" > encrypted.txt && cat encrypted.txt
암호화 모드
암호화된 결과: EAB9BDE6A492E6A799E6A185E6A78AE998A5E6A78BEDAB8BE2908DE290ABE2929CE290BDEDAFA7EDAAA1EDACB0EDA9A0E18793EBB8BEE7A5B4ECAFA2
```

## 1. 개발 배경과 영감

### 1.A 애니그마의 특징

애니그마는 제2차 세계대전 당시 독일군이 사용한 암호화 기계로 당시로서는 매우 복잡하고 안전한 암호화 방식이었다.
애니그마의 핵심 메커니즘으로는 다음과 같은 사항들이 존재한다:

- **로터 시스템**: 여러 개의 회전 디스크(로터)를 통해 문자를 치환
- **플러그보드**: 문자 쌍을 교환하는 추가적인 치환 단계
- **리플렉터**: 신호를 반사하여 역방향으로 로터를 통과시키는 장치

애니그마의 취약점은 주로 운영 방식과 특정 설계 제한(예: 문자가 자기 자신으로 암호화되지 않는 특성)에 있다.

### 1.B AES의 현대적 강점

AES는 2001년 미국 국립표준기술연구소(NIST)에 의해 표준으로 채택된 현대 암호화 알고리즘으로 아래의 특징을 가진다:

- **치환-순열 네트워크(SPN)**: 비선형 치환(S-Box)과 선형 변환을 반복
- **라운드 기반 구조**: 여러 라운드의 변환을 통한 높은 보안성
- **키 스케줄링**: 초기 키에서 각 라운드에 사용될 서브키 생성


## 2. 프로블레마 알고리즘의 핵심

프로블레마는 애니그마와 AES의 장점을 결합하면서 다음과 같은 혁신적 요소를 도입하였다:

### 2.A 확장된 유니코드 기반 로터 시스템

기존 애니그마의 26개 알파벳 제한을 넘어, 프로블레마는 유니코드 전체 문자를 처리할 수 있는 가상 로터 시스템을 구현하였다:

- **다중 유니코드 평면 처리**: 기본 다국어 평면(BMP)을 포함한 여러 유니코드 평면 지원
- **동적 로터 매핑**: 키에 따라 로터의 매핑이 동적으로 생성
- **비선형 회전 메커니즘**: 로터 회전이 단순한 오도메터 방식이 아닌 복잡한 패턴을 따름

### 2.B 다차원 문자 매핑

프로블레마는 단순한 1:1 문자 치환을 넘어 다차원적 문자 매핑을 구현한다:

- **문맥 의존적 치환**: 이전 문자와 현재 상태에 따라 치환 방식이 변화
- **계층적 매핑**: 문자 코드 포인트의 여러 부분(비트 그룹)에 대한 개별적 변환
- **가변 길이 처리**: UTF-8과 같은 가변 길이 인코딩의 효율적 처리

### 2.C AES 영감 블록 변환

AES의 강력한 혼돈(confusion)과 확산(diffusion) 특성을 활용한다:

- **확장된 S-Box**: 유니코드 문자에 적용 가능한 비선형 치환표
- **블록 기반 처리**: 개별 문자가 아닌 문자 블록 단위의 처리
- **다중 라운드 변환**: 반복적인 변환을 통한 높은 보안성

## 3. 알고리즘 구조 상세 설명

### 3.A 데이터 표현 및 처리

프로블레마는 모든 입력 텍스트를 다음과 같이 처리한다:

1. **유니코드 변환**: 모든 입력 문자를 유니코드 코드 포인트로 변환
2. **블록 구성**: 코드 포인트를 128비트(16바이트) 블록으로 구성
3. **패딩**: 필요시 마지막 블록에 PKCS#7 호환 패딩 적용

### 3.B 키 처리 시스템

프로블레마의 키 시스템을 다음과 같이 구성하였다:

1. **마스터 키**: 사용자가 제공하는 256비트(32바이트) 키
2. **키 확장**: 마스터 키에서 다음 구성 요소를 위한 서브키 생성:
   - 로터 초기 상태 키
   - 플러그보드 구성 키
   - AES 라운드 키
   - 피드백 메커니즘 키

### 3.C 암호화 과정 상세 흐름

각 블록의 암호화는 다음 단계로 진행된다:

#### 3.C.a 초기 변환 단계

1. **초기 XOR**: 입력 블록과 키 파생 값의 XOR 연산
2. **플러그보드 변환**: 다차원 매핑 테이블을 통한 초기 치환

#### 3.C.b 로터 단계

1. **순방향 로터 통과**: 8개의 가상 로터를 순차적으로 통과
   - 각 로터는 유니코드 코드 포인트에 대한 치환표 적용
   - 각 문자 처리 후 로터 회전 (비선형 패턴에 따라)
2. **중간 변환**: AES 영감 S-Box를 통한 비선형 변환
3. **역방향 로터 통과**: 다른 회전 패턴을 가진 로터 세트를 역순으로 통과

#### 3.C.c AES 영감 변환 단계

1. **SubBytes**: 각 바이트에 대한 비선형 S-Box 변환
2. **ShiftRows**: 블록 내 행 순환 이동
3. **MixColumns**: 갈루아 필드 연산을 통한 열 혼합
4. **AddRoundKey**: 라운드 키와의 XOR 연산

#### 3.C.d 피드백 및 마무리 단계

1. **상태 업데이트**: 현재 블록의 결과가 다음 블록 처리에 영향
2. **최종 변환**: 추가적인 비선형 변환 및 키 혼합

### 3.D 복호화 과정

복호화는 암호화의 정확한 역순으로 진행된다:

1. **역방향 최종 변환**
2. **역방향 AES 변환**:
   - 역 AddRoundKey
   - 역 MixColumns
   - 역 ShiftRows
   - 역 SubBytes
3. **역방향 로터 처리**:
   - 암호화와 정확히 반대 순서로 로터 통과
   - 정확한 역방향 회전 패턴 적용
4. **역방향 플러그보드 및 초기 변환**

## 4. 한글 및 영어 처리 메커니즘

프로블레마의 핵심 특징 중 하나는 한글과 영어 교차지원을 포함한 다국어 텍스트의 효율적 처리에 있다:

### 4.A 유니코드 처리 최적화

1. **UTF-8 인코딩 인식**: UTF-8로 인코딩된 입력 텍스트의 효율적 처리
2. **코드 포인트 정규화**: 한글 자모 결합 등의 정규화 처리
3. **문자 경계 인식**: 가변 길이 문자의 경계를 인식하여 처리

### 4.B 한글 특화 처리

1. **완성형 한글 처리**: 유니코드 U+AC00~U+D7A3 범위의 완성형 한글 처리
2. **조합형 한글 지원**: 필요시 조합형 한글 자모(U+1100~U+11FF, U+3130~U+318F)도 지원
3. **한글 특성 고려**: 한글의 통계적 특성을 고려한 암호화 강화

### 4.C 혼합 텍스트 처리

1. **언어 경계 무시**: 한글과 영어가 혼합된 텍스트를 원활하게 처리
2. **일관된 보안 강도**: 모든 문자에 대해 동일한 수준의 보안 강도 유지
3. **문맥 인식 암호화**: 문자 간의 문맥적 관계를 고려한 암호화

## 5. 보안 분석

### 5.A 암호학적 강도

프로블레마는 다음과 같은 암호학적 강도를 제공한다:

1. **키 공간**: 256비트 키 공간으로 2^256의 가능한 키 조합
2. **비선형성**: 다중 S-Box와 복잡한 변환을 통한 높은 비선형성
3. **확산 특성**: 입력의 작은 변화가 출력 전체에 영향을 미치는 강한 확산 특성

### 5.B 알려진 공격에 대한 저항성

1. **차분 암호 분석**: 다중 라운드와 비선형 변환으로 인한 높은 저항성
2. **선형 암호 분석**: 복잡한 키 스케줄링과 비선형 S-Box로 인한 방어
3. **관련 키 공격**: 강력한 키 스케줄링 알고리즘으로 방어
4. **사이드 채널 공격**: 구현 시 대응 방안 고려 필요

### 5.C 애니그마 취약점 개선

1. **자기 암호화 방지 제거**: 문자가 자기 자신으로 암호화될 수 있도록 설계
2. **결정적 패턴 제거**: 애니그마의 예측 가능한 패턴 제거
3. **키 관리 강화**: 강력한 키 관리 시스템 도입

## 6. 성능 및 구현 고려사항

### 6.A 계산 복잡성

1. **시간 복잡도**: O(n) - 입력 크기에 선형적 비례
2. **공간 복잡도**: 로터 테이블과 S-Box를 위한 고정 메모리 요구

### 6.B 최적화 전략

1. **룩업 테이블**: 자주 사용되는 변환을 위한 사전 계산된 테이블
2. **병렬 처리**: 독립적인 블록의 병렬 처리 가능성
3. **하드웨어 가속**: 특정 연산의 하드웨어 가속 가능성

### 6.C 구현 권장사항

1. **모듈화**: 기능별 모듈 분리를 통한 유지보수성 향상
2. **보안 코딩**: 버퍼 오버플로우 등의 취약점 방지
3. **테스트 벡터**: 알고리즘 정확성 검증을 위한 테스트 벡터 제공

## 7. 응용 시나리오

프로블레마는 다음과 같은 응용 분야에 적합할 것이라 기대된다:

1. **다국어 문서 암호화**: 한글과 영어가 혼합된 문서의 안전한 보관
2. **통신 보안**: 다국어 메시지의 안전한 전송
3. **데이터베이스 암호화**: 다국어 데이터의 필드 수준 암호화
4. **교육 및 연구**: 현대 암호학과 역사적 암호 시스템의 연결점 연구

## 8. 결론

프로블레마 암호화 알고리즘은 역사적인 애니그마의 개념적 우아함과 현대 암호학의 강력한 보안 특성을 결합하여 특히 다국어 환경에서 효과적으로 작동하는 새로운 암호화 솔루션을 제공한다. 이 알고리즘은 학술적 관심과 실용적 응용 모두에 가치가 있는 혁신적인 접근법을 제시하려는 목적으로 고안되었다.

프로블레마는 단순한 암호화 도구를 넘어 암호학의 역사와 현대 기술의 융합을 특별한 방식으로 서술한다.